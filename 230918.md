# 230918
# 지난 학습내용 잠깐 정리
## 알고리즘 설계 기법의 종류
1. 전체를 다 보자 (Brute Force - 완전탐색)
   - 배열 : 반복문을 다 돌리기
   - 그래프 : DFS, BFS
2. 상황마다 좋은 걸 고르자 (Greedy - 탐욕)
   - 규칙을 찾는 것
   - 주의사항 : 항상 좋은 것을 뽑아도, 최종 결과가 제일 좋다는게 보장되지 않는다.
3. 하나의 큰 문제를 작은 문제로 나누어 부분적으로 해결하자 (Dynamic Programming)
   - Memoization 기법을 활용
   - 점화식(bottom-up), 재귀(top-down)
4. 큰 문제를 작은 문제로 쪼개서 해결하자 (Divide and Conquer - 분할 정복)
5. 전체 중 가능성 없는 것을 빼고 보자 (Backtracking - 백트래킹)
   - 가지치기


# 분할 정복 & 백트래킹

## 병합정렬 (Merge Sort)
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합을 만드는 방식
- 분할정복 알고리즘 활용
  - 자료를 최소단위의 문제까지 나눈 후에 차례대로 정렬하여 최종결과를 얻어냄
  - top-down 방식
- 시간복잡도
  - O(n log n)

## 퀵 정렬
- 주어진 배열을 두 개로 분할하고, 각각을 정렬한다.
  - 병합정렬과 동일?
- 차이점1: 병합정렬은 그냥 두 부분으로 나누는 반면에, 퀵 정렬은 분할 할 때, 기준 아이템 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른 편에 위치 시킨다.
- 차이점2:


## Hoare vs Lomuto

sort(), sorted()
내장 라이브러리가 굉장히 강력!

## 병합 정렬
- 직접 구현할 일은 적다
  - 멀티 쓰레드
- 과거에 면접 단골질문 + 분할 정복 학습에 좋다
  - 코드를 보기 전에 반드시 손으로 직접 해보기

## 퀵 정렬
- 직접 구현할 일은 적다
  - 평균적으로 굉장히 좋음 (n log n)
  - 특히, 큰 데이터를 다룰 때 좋다.
  - 단점: 역순 정렬 등 최악의 경우 O(N^2)
- 과거에 면접 단골질문 + 분할 정복 학습에 좋다
  - 코드를 보기 전에 반드시 손으로 직접 해보기


# 이진 탐색

- 이진 탐색은 반드시 정렬된 상태에서 시행되어야 한다
- 코딩 테스트의 메인 알고리즘 중 하나
- 목적 : "원하는 값을 빨리 찾는 것"
- 시간 : O(log N)
  
- [참고] Parametric Search : 특정 범위 검색 
  - lower bound
  - upper bound
  - 예시 : 
    - 여러 개의 데이터 중 2가 처음 나온 시점
    - 2 ~ 9 사이의 데이터는 몇 개인가?



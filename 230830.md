# 230830
# 완전검색 / 그리디

## 반복과 재귀
- 반복과 재귀는 유사한 작업을 수행할 수 있음
- 반복은 수행하는 작업이 완료될 때까지 계속 반복
  - 루프 구조
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
  - 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합
  - 재귀함수로 구현

- 반복구조
  - 초기화
  - 조건검사
  - 반복할 명령문 실행
  - 업데이트

- 반복을 이용한 선택정렬
```python
def SelecrionSort(A):
    n = len(A)
    for i in range(0, n-1):
        minI = i
        for j in range(i+1, n):
            if A[j] < A[minI]:
                minI = j
        ...
```

- 재귀적 알고리즘
  - 재귀적 정의는 두 부분으로 나뉜다
  - 하나또는 그 이상의 기본경우
  - 하나 또는 그 이상의 유도된 경우

- 재귀 함수
  - 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
  - 일반적으로 재귀적 정의를 이용해서 재귀함수를 구현
  - 따라서, 기본 부분과 유도부분으로 구성
  - 재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉬움
    - 그러나, 재귀에 대해 익숙하지 않은 개발자들은 재귀적 프로그램이 어렵다고 느낌
  - 함수호출은 프로그램 메모리 구조에서 스택을 사용, 따라서 재귀호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생

- 재귀함수 기본구조?
```python
def f(i, N):    # i 현재 상태, N 목표
    if i == N:
        return
    else:
        f(i+1, N)
```

## 반복 또는 재귀?
- 해결할 문제를 고려해서 반복이나 재귀의 방법을 선택
- 재귀는 문제해결을 위한 알고리즘 설계가 간단하고 자연스럽다
- 일반적으로, 재귀적 알고리즘은 반복 알고리즘 보다 더 많은 메모리와 연산을 필요로 한다.
- 입력값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.

## 반복과 재귀의 비교


# 완전검색기법
## Baby-gin Game

## 고지식한 방법 (brute-force)
- 문제를 해결하기 위한 간단하고 쉬운 접근법
- 대부분의 문제에 적용가능
- 상대적으로 빠른 시간에 문제 해결을 할 수 있다.
- 문제에 포함된 자료의 크기가 작다면 유용
- 학술적 또는 교육적 목적을 위해 알고리즘의 효율성을 판단하기 위한 척도로 사용됨

### Brute Force 탐색
- 자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행한다.

SequentialSearch(A[0..n], k)

    A[n] <- k
    i <- 0
    WHILE A[i] != k
        i ++
    IF i < n: RETURN i
    ELSE:   RETURN -1

### 완전검색으로 시작하라
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확룔이 작다.
- 이를 기반으로 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다.
- 검정 등에서 주어진 문제를 풀 때, **우선 완전검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확신하는 것이 바람직**하다.


### 완전검색을 통한 baby-gin 접근
- 고려할 수 있는 모든 경우의 수 생성하기


# 순열
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

## 단순하게 순열을 생성하는 방법
- 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 아래와 같이 구현할 수 있다.
...

## 순열 생성방법
- 사전적 순서
- 최소 변경을 통한 방법
- 재귀 호출을 통한 순열 생성


# 부분집합
- 집합에 포함된 원소들을 선택하는 것이다
- 다수의 중요 알고리즘이 원소들의 그룹에서 최적의 부분 집합을 찾는 것이다
- N개의 원소를 포함한 집합
  - 자기자긴 과 공집합 포함한 모든 부분집합의 개수는 2^n 개
  - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

## 부분집합 생성방법
- 바이너리 카운팅을 통한 사전적 순서
  - 부분집합을 생성하기 위한 가장 자연스러운 방법

### 바이너리 카운팅
- 원소 수에 해당하는 N개의 비트열을 이용
- n번 비트값이 1이면 n번 원소가 포함되었음을 의미
